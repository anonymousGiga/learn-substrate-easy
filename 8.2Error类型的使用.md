# Error类型的使用

在前面的讲解写简单的pallet中，我们提到了写pallet的模板，在模板中我们分了大概7个部分。不过这其实只是写pallet的常见的部分，除了这7个部分，实际上还有Error类型我们没有说明。在runtime代码执行时，代码必须是“非抛出的”，或者说不应该panic，应该是优雅的处理错误，所以在写pallet代码时，允许我们自定义错误类型，当错误发生时，可以返回我们定义的错误类型。这里的Error类型是指运行时在执行调度函数（也就是交易函数）时返回的错误。因为在调度函数执行时，返回的结果为DispatchResult类型，当执行结果错误时，返回DispatchError。

# 1 错误类型的定义
和之前我们讲过的Event一样，Error是一个枚举类型，其定义方式如下：
```
#[pallet::error]
pub enum Error<T> {
    //错误类型1
    InvalidParameter,
    //错误类型2
    OutOfSpace,
    ...
    //错误类型3
    InvalidFee,
}
```
可以看到，定义Error类型时，上面是```#[pallet::error]```宏，然后就是Error枚举类型。

# 2 在函数中返回错误
在函数中返回错误的情况，通常如下：
```
pub fn xx_function(origin: OriginFor<T>, ...) 
    -> DispatchResultWithPostInfo {
		...
		if 返回错误条件成立 {
			return Error::<T>::错误类型
		}
		...
		Ok(().into())
}

```
上面是伪代码，具体的我们可以看下面的完整示例。

# 3 简单示例
接下来我们创建一个use-erros的pallet，在其中演示使用Errors类型。为了方便期间，我们直接拷贝之前实现过的use-storage目录，然后将目录名字修改为use-errors，将Cargo.toml中的包名修改为pallet-use-errors。

然后我们修改


# 4 参考文档

# 5 完整代码
