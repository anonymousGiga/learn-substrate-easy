# 写调度函数的套路

调度函数在substrate官方文档里面叫做Extrinsics（外部调用），详细的Extrinsics介绍可以参考[这里](https://docs.substrate.io/v3/concepts/extrinsics/).在substrate中共有三种Extrinsics，分别是Inherents、Signed transactions和Unsigned transactions。而在我们开发pallet的过程中，比较常用到的是后两种，所以我们这里也主要介绍后两种，对于Inherents有兴趣的小伙伴可以自己看官方文档研究下。

# 1 Signed transactions
签名交易包含发起该交易的账户的签名，并会支付交易费用。因为签名交易的合法性可以在执行之前识别，所以它们可以在节点之间的网络上传播，属于垃圾信息的风险比较小。签名交易和比特币、以太坊中的交易的概念类似。

# 2 Unsigned transactions
但是有时候我们希望使用不需要花费交易费的交易。例如一个节点给链发送在线的心跳，表示自己在线，这种情况肯定是不希望花费交易费的，此时我们就可以使用unsigned transaction。但是需要注意的是，由于交易没有签名，因此也没有人支付费用，所以缺乏防止垃圾信息的经济逻辑。所以我们在使用未签名交易时需要特别小心。

# 3 通常的写法
## 3.1 调度函数的位置
所有调度函数都放置在#[pallet::call]标注的代码段内，每个调度函数上面需要标注其调用的权重，并根据需要是否添加#[transactional] 如下：
```
#[pallet::call]
impl<T: Config> Pallet<T> {
		
		#[pallet::weight(10_000)]  //具体的函数使用对应的权重计算函数
		pub fn function1(origin: OriginFor<T>, param: u32, ...) -> DispatchResult {}
    
    #[transactional]
    #[pallet::weight(10_000)]  //具体的函数换成对应的权重计算函数
		pub fn function2(origin: OriginFor<T>, param: u32, ...) -> DispatchResult {}
    
    //其它调度函数
}
```

## 3.2 函数体的写法

在pallet的开发中，不管是签名的交易还是非签名的交易，通常都遵循以下三个步骤进行，分别是：
```
1、判断调用者是否有权限;
2、执行逻辑;
3、发出事件。
```
示例如下：
```
#[pallet::weight(10_000)] 
pub fn set_number_bigger_than_100(origin: OriginFor<T>, number: u32) -> DispatchResult {
    ensure_signed(origin)?;  //1、判断是否是合法调用
    
    // 2、函数的具体逻辑
    ...
    
    //3、成功后需要发出事件
    Self::deposit_event(Event::xx事件);
			
    Ok(()) //固定写法
}
```
这里需要特别说明的是第一步，分三种情况：
```
1、如果是签名调用的则判断的写法是 ensure_signed(origin)?。可以回忆回忆之前的例子（https://github.com/anonymousGiga/learn-substrate-easy-source/blob/main/substrate-node-template/pallets/use-storage/src/lib.rs#L78）    
2、如果是需要root用户调用的则判断的写法是ensure_root(origin)?。可以回忆回忆之前的例子（https://github.com/anonymousGiga/learn-substrate-easy-source/blob/main/substrate-node-template/pallets/use-storage/src/lib.rs#L64）
3、如果非签名的函数调用的判断写法则是ensure_none(origin)?。这里暂时没有例子，后续我们会使用到。
```

## 3.3 权重
从上面的示例中可以看到，每个调度函数上面都需要标注其权重，在具体开发时，我们一般是先写一个固定的权重，然后在所以功能开发完成后，再写对应的benchmarking（在本教程的最后位置会来学习）。
关于权重的详细介绍可以参考[官方文档](https://docs.substrate.io/v3/runtime/weights-and-fees/)。

## 3.4 transactional
当我们去看不管是我们上面的例子还是substrate已经实现好的pallet的调度函数，会发现有些调度函数上面会有```#[transactional]```，有些则没有。这个属性宏实际上是保证调度函数执行的一致性。更具体点说就是当在函数中遇到错误后，会回滚状态，保证错误发生之前写入的状态回滚。解释起来比较敖口，看下面的例子可以很好的理解。
```

```

# 6 示例

# 7 参考文档

# 8 完整源码地址
