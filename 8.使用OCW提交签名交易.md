在区块链的应用中，常见的需求是在把数据上链之前需要去查询链下数据，解决的方式通常是使用预言机，这种方法虽然可行，但在安全性、可伸缩性和基础设施效率方面仍然存在一些缺陷。所以在substrate中为我们提供了一些链下的特性来解决这些需求，分别是：
* 链下工作者（offchain worker）；
* 链下存储（offchain storage）；
* 链下索引（offchain index）。

链下工作者（offchain worker）可以提交签名交易、未签名交易、具有签名负载的未签名交易等功能，本节着重教大家在ocw中使用签名交易的情况。

# 1 在pallet中添加ocw
这个pallet相对于我们以前实现的pallet要复杂一些，因此我们先贴出完整代码，然后再讲解。pallet中的代码如下：
```
#![cfg_attr(not(feature = "std"), no_std)]

//=========================
//需要关注的第一部分
//=========================
use sp_core::crypto::KeyTypeId;
pub const KEY_TYPE: KeyTypeId = KeyTypeId(*b"demo");
pub mod crypto {
	use super::KEY_TYPE;
	use sp_runtime::app_crypto::{app_crypto, sr25519};
	app_crypto!(sr25519, KEY_TYPE);
}
pub type AuthorityId = crypto::Public;
//==========================

pub use pallet::*;
#[frame_support::pallet]
pub mod pallet {
	use frame_support::pallet_prelude::*;
	use frame_system::pallet_prelude::*;

	use frame_system::offchain::{
		AppCrypto, CreateSignedTransaction, SendSignedTransaction, Signer,
	};

	#[pallet::pallet]
	#[pallet::generate_store(pub(super) trait Store)]
	pub struct Pallet<T>(_);

  //=========================
  //需要关注的第二部分
	#[pallet::config]
	pub trait Config: frame_system::Config + CreateSignedTransaction<Call<Self>> {
		type AuthorityId: AppCrypto<Self::Public, Self::Signature>;
		type Event: From<Event<Self>> + IsType<<Self as frame_system::Config>::Event>;
	}
  //=========================

	#[pallet::storage]
	pub type SomeInfo<T: Config> = StorageMap<_, Blake2_128Concat, u64, u64, ValueQuery>;

	#[pallet::event]
	#[pallet::generate_deposit(pub(super) fn deposit_event)]
	pub enum Event<T: Config> {
		SetSomeInfo(u64, u64),
	}

	#[pallet::error]
	pub enum Error<T> {
		OffchainSignedTxError,
		NoAcctForSigning,
	}
  
  //=========================
  //需要关注的第三部分
  //=========================
	#[pallet::hooks]
	impl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {
		fn offchain_worker(block_number: T::BlockNumber) {
			log::info!(target: "ocw", "before offchain_worker set storage: {:?}", block_number);
			let result = Self::offchain_signed_tx(block_number);
			log::info!(target: "ocw", "after offchain_worker set storage: {:?}", block_number);

			if let Err(e) = result {
				log::error!(target:"ocw", "offchain_worker error: {:?}", e);
			}
		}
	}

	#[pallet::call]
	impl<T: Config> Pallet<T> {
		#[pallet::weight(0)]
		pub fn submit_something_signed(
			origin: OriginFor<T>,
			number: u64,
		) -> DispatchResultWithPostInfo {
			log::info!(target:"ocw", "11111 +++++++++++++++++++ ");
			ensure_signed(origin)?;

			let mut cnt: u64 = 0;
			if number > 0 {
				cnt = number;
			}

			log::info!(target:"ocw", "+++++++++++++++++++ offchain_worker set storage: {:?}, cnt: {:?}", number, cnt);
			SomeInfo::<T>::insert(&number, cnt);

			Self::deposit_event(Event::SetSomeInfo(number, cnt));
			Ok(().into())
		}
	}

	impl<T: Config> Pallet<T> {
		fn offchain_signed_tx(block_number: T::BlockNumber) -> Result<(), Error<T>> {
			let signer = Signer::<T, T::AuthorityId>::any_account();
			log::info!(target:"ocw", "+++++++++++++++++++, can sign: {:?}", signer.can_sign());

			let number: u64 = block_number.try_into().unwrap_or(0);
       
      //需要关注的3.1
			let result =
				signer.send_signed_transaction(|_acct| Call::submit_something_signed { number });

			if let Some((_acc, res)) = result {
				if res.is_err() {
					return Err(<Error<T>>::OffchainSignedTxError)
				}
				Ok(())
			} else {
				Err(<Error<T>>::NoLocalAcctForSigning)
			}
		}
	}
}

```
对于pallet中的代码实现，我们主要需要实现三部分，分别解释如下：
* 第一部分
  
  这部分主要是
* 第二部分
* 第三部分

# 2 在runtime中添加相关代码

# 3 调试

# 4 参考资料
https://github.com/JoshOrndorff/recipes/blob/master/text/off-chain-workers/transactions.md

# 5 完整代码地址
https://github.com/anonymousGiga/learn-substrate-easy-source/tree/main/substrate-node-template/pallets/ocw-sigtx/src
