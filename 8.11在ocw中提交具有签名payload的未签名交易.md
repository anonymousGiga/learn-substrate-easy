# 在ocw中提交具有签名payload的未签名交易

本节我们继续学习在ocw中提交未签名交易，不过和上一节不同的是，我们这里提交的交易是未签名的交易，但是交易中提交的payload是签过名的。因为交易是未签名的，所以这个交易是没有手续费的，但是交易中的负载是签过名的，所以可以对其中的负载进行验证，可以保证内容的可信性。

如果我们开发的系统中，需要自动从链下往链上提交某些信息以用于我们的业务逻辑，但是我们又不能在这些提交上花费交易费用，那么我们就可以选择在ocw中使用具有签名payload的未签名交易的形式。

下面我们就学习在ocw中使用具有签名payload的未签名交易的例子。

# 1 pallet中的实现
## 1.1 在ocw中签名的子模块
这部分实现和我们在[章节使用OCW提交签名交易](8.9使用OCW提交签名交易.md)中提到过的一样，主要是用来在offchain worker对payload签名的子模块。在实际的开发中，这部分基本上是固定的写法。在substrate中支持ed25519和sr25519，我们此处使用的是sr29915作为例子。其中KEY_TYPE是offchain worker签名时检索key使用的类型，由开发者指定，我们这里还是指定为“demo”。代码如下：
```
use sp_core::crypto::KeyTypeId;
pub const KEY_TYPE: KeyTypeId = KeyTypeId(*b"demo");

pub mod crypto {
	use super::KEY_TYPE;
	use sp_runtime::app_crypto::{app_crypto, sr25519};
	app_crypto!(sr25519, KEY_TYPE);
}
```

## 1.2 config配置
这里的写法也基本上和[章节使用OCW提交签名交易](8.9使用OCW提交签名交易.md)中提到过的一样，如下：
```
#[pallet::config]
pub trait Config: frame_system::Config + CreateSignedTransaction<Call<Self>> {
	type AuthorityId: AppCrypto<Self::Public, Self::Signature>;
	type Event: From<Event<Self>> + IsType<<Self as frame_system::Config>::Event>;
}
```


# 2 在runtime中添加

# 3 完整参考源码

